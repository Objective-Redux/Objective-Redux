<h1>Getting Started</h1>

<h2>Setup</h2>

<h3>Installing Packages</h3>

<p>In order to use Objective Redux in your project, you'll need to install it along with Redux. These should be saved as dependencies, since they will need to be run with the final application.</p>

<pre><code>npm install --save redux objective-redux</code></pre>

<p>If you want to use Redux-Saga, install it as well.</p>

<pre><code>npm install --save redux-saga</code></pre>

<h3>Adding a Provider (React)</h3>

<p>If you're using React, you'll need to setup a provider for the ReduxRegister class. This will allow you to access the register instance from your components, either by connecting the component to the provider or by using the provided React hook.</p>

<pre><code class="language-typescript">
import React from 'react';
import ReactDOM from 'react-dom';
import { RegisterProvider, ReduxRegister } from 'objective-redux';
import App from './app';

export const register = new ReduxRegister();

ReactDOM.render(
  &lt;RegisterProvider register={register}&gt;
    &lt;App /&gt;
  &lt;/RegisterProvider&gt;,
  document.getElementById('root')
);
</code></pre>

<h2>Creating Slices</h2>

<p>In Objective-Redux, a StateController handles the access and mutation of a slice of state. Every time you instantiate a StateController, the reducer associated with that state is added automatically to the ReduxRegister.</p>

<p>The stateName and the initialState are sent to the super constructor. The stateName will identify the piece of the state the controller is operating on and the initialState determines the starting configuration it.</p>

<p>Actions and their associated mutations are created by using the registerAction method. This method takes a function that, in turn, accepts the current state and the action payload as parameters and returns the new state.</p>

<p>Below is an example of a state controller that flips a switch on and off.</p>

<pre><code class="language-typescript">
import { StateController } from 'objective-redux';

const initialState = { isOn: false };

class SwitchStateController extends StateController {
  constructor(register) {                   // The generated reducer is added
    super(initialState, register);          // to the ReduxRegister. No need
  }                                         // to wire it up manually.

  static getName() {                        // Sets the name of the slice.
    return 'switch';
  }

  toggleSwitch = this.registerAction(       // This creates a reducer and
    (state) => ({ isOn: !state.isOn })      // returns the associate action.
  );
}

export SwitchStateController;
</code></pre>

<p>Below are two examples of how the above class would be used with React.</p>

<p>With a connected component:</p>

<pre><code class="language-typescript">
import React from 'react';
import { ComponentConnector } from 'objective-redux';
import { SwitchStateController } from './store/switch-state-controller';

function AppComponent(props) {
  const { isOn, register } = props;

  const sendToggleAction = () => {
    SwitchStateController.getInstance(register).toggleSwitch();
  }

  return (
      &lt;button onClick={sendToggleAction}&gt;
        Turn the switch { isOn ? 'Off' : 'On' }
      &lt;/button&gt;
  );
}

export default ComponentConnector
  .addPropsTo(AppComponent)
  .from(SwitchStateController) // or .from(SwitchStateController, state => ({ isOn: state.isOn }))
  .connect();
</code></pre>

<p>With a React hook:</p>

<pre><code class="language-typescript">
  import React from 'react';
  import { useController } from 'objective-redux';
  import { SwitchStateController } from './store/switch-state-controller';
  
  function AppComponent() {
    const switchController = useController(SwitchStateController);
    const { isOn } = switchController.getStateSlice();
  
    const sendToggleAction = () => {
      switchController.toggleSwitch();
    }
  
    return (
        &lt;button onClick={sendToggleAction}&gt;
          Turn the switch { isOn ? 'Off' : 'On' }
        &lt;/button&gt;
    );
  }
  </code></pre>

<h2>Creating Sagas</h2>

<p>Sagas can be created using the StatelessController. The createSagaWithType is passed a take type for the saga, defining how de-duplication of the events should be handled. Then, the register method is called and passed the generator function the saga will execute.</p>

<p>Below is an example of a Saga that will call the toggleSwitch method of our previously created SwitchStateController.</p>

<pre><code class="language-typescript">
import {
  StatelessController,
  TakeType,
  getControllerFromSagaContext
} from 'objective-redux';
import { SwitchStateController } from './switch-state-controller';

export class SwitchStateSagas extends StatelessController {
  static getName() {
    return 'Switch-State-Sagas';
  }

  toggleSwitch = this.createSaga()
    .withTake(TakeType.TAKE_LATEST)
    .register(
      function* () {
        const switchController = yield getControllerFromSagaContext(SwitchStateController);
        yield switchController.toggleSwitchValue(payload);
      }
    );
}
</code></pre>